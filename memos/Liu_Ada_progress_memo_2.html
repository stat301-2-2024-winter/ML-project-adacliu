<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ada Liu">
<meta name="dcterms.date" content="2024-02-22">

<title>Progress Memo 2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Liu_Ada_progress_memo_2_files/libs/clipboard/clipboard.min.js"></script>
<script src="Liu_Ada_progress_memo_2_files/libs/quarto-html/quarto.js"></script>
<script src="Liu_Ada_progress_memo_2_files/libs/quarto-html/popper.min.js"></script>
<script src="Liu_Ada_progress_memo_2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Liu_Ada_progress_memo_2_files/libs/quarto-html/anchor.min.js"></script>
<link href="Liu_Ada_progress_memo_2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Liu_Ada_progress_memo_2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Liu_Ada_progress_memo_2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Liu_Ada_progress_memo_2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Liu_Ada_progress_memo_2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Progress Memo 2</h1>
<p class="subtitle lead">Final Project<br>Data Science 2 with R (STAT 301-2)</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ada Liu </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 22, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
GitHub Repo
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><a href="https://github.com/stat301-2-2024-winter/final-project-2-adacliu.git" class="uri">https://github.com/stat301-2-2024-winter/final-project-2-adacliu.git</a></p>
</div>
</div>
</div>
<section id="analysis-plan" class="level2">
<h2 class="anchored" data-anchor-id="analysis-plan">Analysis Plan</h2>
<section id="data-splitting" class="level3">
<h3 class="anchored" data-anchor-id="data-splitting">Data Splitting</h3>
<p>In this section, the <a href="https://www.kaggle.com/datasets/uciml/mushroom-classification?resource=download">data set</a> will be split into train and test data sets. The train data will be used to develop predictive models while their performance will be evaluated on the test data. Splitting will be done in a stratified manner (80/20 ratio) by maintaining almost equal fraction of samples for the two classes in both the train and test data sets. However, firstly, we will load in the packages that will be used.</p>
<p>Before the classification models are developed, data exploration will be performed to detect any possible issues with the data set. Here, the split train data will be used, while any possible issues discovered will be applied on both the train and test data using the data preprocessing recipes that will be created.</p>
</section>
<section id="model-development-evaluation-and-selection" class="level3">
<h3 class="anchored" data-anchor-id="model-development-evaluation-and-selection">Model Development, Evaluation and Selection</h3>
<section id="model-types" class="level4">
<h4 class="anchored" data-anchor-id="model-types">Model Types</h4>
<p>Six classification models wii be used. They include:</p>
<ul>
<li><p>Naive Bayes (baseline model)</p></li>
<li><p>Unpenalized logistic regression</p></li>
<li><p>Ridge logistic regression</p></li>
<li><p>Decision trees</p></li>
<li><p>Random forests</p></li>
<li><p>Gradient boosting (Xgboost).</p></li>
</ul>
<p>Classification models will be used in this project because the aim is to distinguish mushrooms into two: edible and poisonous based on their physical traits.</p>
</section>
<section id="resampling-method" class="level4">
<h4 class="anchored" data-anchor-id="resampling-method">Resampling method</h4>
<p>The cross-validation resampling method will be used. First, two resamples of the data set will be created, one will be used for tuning hyperparameters to reduce overfitting and the other will be used to determine the model’s performance using the optimal parameters. Obtaining better performance will be based on accuracy. Also, the optimal parameters will be used to fit the whole train data set and evaluated on the heldout test data set.</p>
<p>To ascertain the model’s performance, the accuracy metric will be used. This is because both class proportion is almost similar (51.8% edible and 48.2% poisonous). Other evaluation metrics such as recall, precision, area-under-the-receiver’s operating characteristics, specificity and F1 will be used also. After the performance of the models have been evaluated, classification model with the best accuracy will be selected as the best model.</p>
</section>
<section id="recipes" class="level4">
<h4 class="anchored" data-anchor-id="recipes">Recipes</h4>
<p>Two different recipes will be created. These recipes will contain pipelines for data preprocessing. This is because the variables are in a format not suitable for analysis, hence we need to preprocess them. One recipe will be used for logistic regression. This recipe will have the categorical variables transformed as numerical variables (dummy variables) where one category from all categorical variables will be used as reference since logistic regression requires that. The other recipe, will have categorical variables one-hot encoded where each category will be a binary variable, where 1 is used to represent its presence and 0, its absence. In both recipes, other data preprocessing and feature engineering steps to be taken include, converting data types from string to factor type, removing variables with one unique value, creating a binary variable <em>bad_smell</em> which indicates mushrooms with a bad smell and replacing the missing value (?) in the <em>stalk_root</em> variable with ‘unk’ to indicate that it is unknown.</p>
<p>Additionally, one more recipe will be created. This recipe will contain the data preprocessing steps outlined in the previous recipes but as an addition contain selected important features obtained from a fitted decision tree. This new recipe will be used by the classification models to fit the training data and performance evaluated on the test data.</p>
</section>
<section id="model-performance-table" class="level4">
<h4 class="anchored" data-anchor-id="model-performance-table">Model Performance Table</h4>
<table class="table">
<caption><strong><em>Table 1: Model Performance</em></strong></caption>
<thead>
<tr class="header">
<th>Model</th>
<th>Accuracy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Naive Bayes</td>
<td>0.972</td>
</tr>
<tr class="even">
<td>Logistic Regression</td>
<td>0.999</td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="current-status-and-next-steps" class="level2">
<h2 class="anchored" data-anchor-id="current-status-and-next-steps">Current Status and Next steps</h2>
<p>Currently, data splitting into train and test data and data exploration are completed. So far, potential data issues have been found. One is the encoding of missing values as “?” and this is found in one variable. Additionally, all predictors are categorical, one variable <em>veil-type</em> has only one unique category in it. Also, some variables were identified from which new variables can be generated.</p>
<p>Baseline (naive Bayes) and logistic regression models have been fit and evaluated on resamples. An issue seen is the almost perfect accuracy obtained by logistic regression. Next steps are to complete the other four classification models, evaluate performance, feature selection and hyperparameter tuning to obtain optimal parameters for models with tunable parameters. Finally, the best model will be selected based on accuracy.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>